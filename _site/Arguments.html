<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=a2558bba89a12ee1edf1780fa754bd31ee729e66">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Arguments | Rooster</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Arguments" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Rooster is a Kotlin-Paper Framework designed to take care of every step in Plugin Managment. Project yet in development Phase." />
<meta property="og:description" content="Rooster is a Kotlin-Paper Framework designed to take care of every step in Plugin Managment. Project yet in development Phase." />
<link rel="canonical" href="http://localhost:4000/Arguments.html" />
<meta property="og:url" content="http://localhost:4000/Arguments.html" />
<meta property="og:site_name" content="Rooster" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Arguments" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Rooster is a Kotlin-Paper Framework designed to take care of every step in Plugin Managment. Project yet in development Phase.","headline":"Arguments","url":"http://localhost:4000/Arguments.html"}</script>
<!-- End Jekyll SEO tag -->

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          
            <a id="forkme_banner" href="https://github.com/CypDasHuhn/Rooster">View on GitHub</a>
          

          <h1 id="project_title">Rooster</h1>
          <h2 id="project_tagline">Rooster is a Kotlin-Paper Framework designed to take care of every step in Plugin Managment. Project yet in development Phase.</h2>

          
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1 id="arguments">Arguments</h1>

<p>An abstraction of the usual way of creating commands,
similar to Brigardier. Your Command is a tree split into multiple Arguments,
which represent the control flow. You can either manually create an Argument,
or use one of the many custom constructors specially designed for one task,
like a list argument, number argument or any other component you may want.
Create your own constructors and use them later on,
or recommend them to the Rooster Repos! The API is very flexible.</p>

<h2 id="usage">Usage</h2>

<p>To Register a new command, simply create an annotated field anywhere.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@RoosterCommand</span>
<span class="kd">val</span> <span class="py">yourCommand</span> <span class="p">=</span> <span class="nc">RootArgument</span><span class="p">(</span>
        <span class="cm">/* further information here */</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>Rooster will pick it up for you and register it. <br />
Remember to include your new command in the plugin.yml,
else Paper won’t be able to detect it.</p>

<h2 id="argument-types">Argument Types</h2>

<p>The ArgumentAPI provides four different types of arguments.
Root-, Central-, Modifier- and regular Argument.
These classes can mutate to each other, and you can also create an
UnsafeArgument which doesn’t have constructor limitations.</p>

<h3 id="regular-argument">Regular Argument</h3>

<p>This is the standard argument, the other types are mirrors of this type
with modifications. Which fields it specifically holds, can be viewed
at <a href="#core-fields">Core Fields</a> / <a href="#other-fields">Other Fields</a>.</p>

<h3 id="central-argument">Central Argument</h3>

<p>The Central Argument is identical to the Regular Argument, except that the <a href="#error-missing">Error Missing</a>
Field is forced to be filled by the constructor. You can use a CentralizedArgumentList
in the <a href="#following-arguments">Following Arguments</a> of another Argument, and then fill the List
with a Central Argument. Generally, if your child-parent relationship is that an Argument is the Main Child, use a
CentralArgument
as the logic for handling Missing Arguments will be encapsulated at the correct place.</p>

<h3 id="root-argument">Root Argument</h3>

<p>The Root Argument is the one which you use at the top to create
a new command. It gets two new fields, the <a href="#label">Label</a> which is
the name of the command, for example with <code class="language-plaintext highlighter-rouge">/tp @s 200 70 200</code> ‘tp’ is the label here.
And the <a href="#starting-unit">Starting Unit</a> field, which is invoked at the complete beginning
of the command parsing, and will determine whether the command should be executed. Take for example that you dont allow
CommandSenders which aren’t
players, or based on the sender you load and cache some specific data.</p>

<h3 id="modifier-argument">Modifier Argument</h3>

<p>The Modifier Argument is the most different from the other Arguments.
It gets treated by the Parser differently then the others, with other
Argument instances, when you enter an argument, the parser dives into the sub-tree
of that argument. With the Modifier Argument it doesn’t change your position in the
Argument Tree, but rather if present it provides extra information. Take flags as an example,
like <code class="language-plaintext highlighter-rouge">/customCommand customArgument</code> could be also used with <code class="language-plaintext highlighter-rouge">/customCommand -flag customArgument</code>,
the tree isn’t changed, but you can access the values later on (
Invocation/Completion).</p>

<h2 id="core-fields">Core Fields</h2>

<h3 id="key">Key</h3>
<p><code class="language-plaintext highlighter-rouge">String</code><br /></p>

<p>The unique identifier for each command argument. This key allows access to specific values associated with the argument during command execution. Every argument must have a <code class="language-plaintext highlighter-rouge">key</code>.</p>

<h3 id="tab-completions">Tab Completions</h3>
<p><code class="language-plaintext highlighter-rouge">ArgumentInfo =&gt; List&lt;String&gt;</code> (<a href="#argumentinfo">ArgumentInfo</a>) <br /></p>

<p>A lambda function that provides the tab completions based on the current context. Every Argument needs a Tab Completion.</p>
<h3 id="following-arguments">Following Arguments</h3>
<p><code class="language-plaintext highlighter-rouge">ArgumentList</code>(<a href="#argumentlist">argumentList</a>)</p>

<p>A list of arguments that can follow the current argument in the command structure. 
This field enables the creation of a hierarchical command structure where each argument can lead to more 
specific sub-arguments.</p>
<h3 id="invoke">Invoke</h3>
<p><code class="language-plaintext highlighter-rouge">InvokeInfo =&gt; Unit</code> (<a href="#invokeinfo">InvokeInfo</a>)</p>

<p>A lambda function that defines the action to be executed when the command is invoked with valid arguments. 
This allows for customizable behavior when a command is successfully parsed. 
An Invoke function is always invoked with parsed arguments.</p>

<h3 id="is-valid"><code class="language-plaintext highlighter-rouge">Is Valid</code></h3>

<p>A validation function that checks whether the current argument is valid in the given context.
This can be used to enforce rules about what arguments can be used together or under certain conditions.</p>

<h2 id="other-fields">Other Fields</h2>

<h3 id="is-valid-completer"><code class="language-plaintext highlighter-rouge">Is Valid Completer</code></h3>

<p>A validation function specifically for tab completion contexts. 
This checks if the argument is valid when the user is requesting completions, 
allowing for dynamic suggestions based on the argument state.</p>

<h3 id="is-argument"><code class="language-plaintext highlighter-rouge">Is Argument</code></h3>

<p>A boolean flag indicating whether the current instance is a valid argument in the command structure. 
This can be useful for differentiating between argument types during parsing. Use this before checking validness and potentially sending an error.</p>

<h3 id="error-missing"><code class="language-plaintext highlighter-rouge">Error Missing</code></h3>

<p>A lambda function that defines the action to be taken when a required argument is missing. This allows for custom error handling to inform the user about the specific arguments that were not provided.</p>

<h3 id="error-missing-child-arg"><code class="language-plaintext highlighter-rouge">Error Missing Child Arg</code></h3>

<p>A lambda function that handles the situation where a required child argument of the current argument is missing. This can provide more granular error messages for nested arguments.</p>

<h3 id="argument-handler"><code class="language-plaintext highlighter-rouge">Argument Handler</code></h3>

<p>A lambda function that processes the argument value when it is validated and invoked. This function defines how to handle the data associated with the argument, enabling custom processing logic. Often used together with <a href="#is-valid">Is Valid</a> to handle the processed result.</p>

<h3 id="starting-unit-root-only"><code class="language-plaintext highlighter-rouge">Starting Unit</code> (Root Only)</h3>

<p>A lambda function that is called at the beginning of command parsing to determine whether the command should proceed. This is typically used to enforce preconditions based on the command sender or other contextual factors.</p>

<h3 id="label-root-only"><code class="language-plaintext highlighter-rouge">Label</code> (Root Only)</h3>

<p>The name of the command as it appears in user input. For example, in the command <code class="language-plaintext highlighter-rouge">/tp @s 200 70 200</code>, the label is <code class="language-plaintext highlighter-rouge">tp</code>. This field is essential for matching user input to the correct command handler.</p>

<h2 id="data-classes">Data Classes</h2>
<h3 id="argumentinfo">ArgumentInfo</h3>

<h3 id="invokeinfo">InvokeInfo</h3>

<h3 id="argumentlist">ArgumentList</h3>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p class="copyright">Rooster maintained by <a href="https://github.com/CypDasHuhn">CypDasHuhn</a></p>
        
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
